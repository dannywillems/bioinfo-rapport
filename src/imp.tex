%!TEX root=rapport.tex
\section{Implémentation}

\subsection{Idée générale}

	L'idée générale de l'alignement de séquences est de permettre, à partir d'un ensemble de séquences, de créer à l'aide de chevauchements approximatifs un \emph{contig}. Pour ce faire, notre démarche se découpe en plusieurs parties:

	\begin{description}
		\item[Récupération et stockage des données] Afin de pouvoir former le contig souhaité, il est nécessaire de récupérer les séquences et de les stocker de manière efficace. Cette étape est expliquée dans la section~\ref{subsection:recStock}.

		\item[1. Alignement semi-global] Ensuite, pour chaque paire de séquences,
			nous effectuons un \emph{alignement semi-global} en nous inspirant
			de l'algorithme vu en cours. Cette méthode nous donne ainsi
			les chevauchements approximatifs des deux séquences, ce qui permet de
			prendre en compte le fait qu'il ait pu y avoir des erreurs lors du
			séquençage. Si la paire est notée $(s, t)$, cette étape nous permet également de connaitre la plus
			grande chaine qui est suffixe de $s$ et préfixe de $t$ (à erreurs de séquençage près). Cette étape
			est expliquée dans la section~\ref{subsection:semiGlobal}.

		\item[2. Algorithme greedy] Une fois les alignements approximatifs
			calculés, il est encore nécessaire de trouver dans quel ordre
			ceux-ci doivent être assemblés afin de former le meilleur contig.
			Pour ce faire, nous utilisons un \emph{algorithme glouton} qui, à
			partir d'un graphe permet de trouver un chemin hamiltonien afin de
			reconstituer le contig. Cette étape est expliquée dans la
			section~\ref{subsection:greedy}.

		\item[3. Alignement]
			L'algorithme glouton nous donnant, dans l'ordre, les séquences à
			aligner, il est nécessaire de reconstruire cet alignement en
			ajoutant des gaps pour que chaque séquence ait la même longueur et
			qu'on puisse calculer le consensus. Cette étape est expliquée dans
			la section ~\ref{subsection:alignment}.

		\item[4. Consensus]
			Après que l'alignement ait été réalisé, il nous faut calculer le
			consensus en fonction de ce dernier. Cette étape est expliquée dans
			la section ~\ref{subsection:consensus}.
	\end{description}

\subsection{Récupération et stockage des données}
\label{subsection:recStock}

Des sous-séquences brutes d'ADN sont stockées dans des fichiers au format FASTA, il nous est donc nécessaire de les récupérer. Cette étape est effectuée au travers des classes \verb|FastaReader| et \verb|Sequence|. En effet, la classe \verb|FastaReader| génère une liste de séquences à partir des séquences stockées dans le fichier FASTA. De plus, la classe \verb|FastaWriter| est utilisée afin de récupérer le résultat du procédé visant à trouver le meilleur contig.
\\

La classe \verb|Segment| permet de stocker sous forme d'un tableau d'octets un fragment d'ADN. Nous prenons la convention suivante quant à la représentation des nucléotides et d'un gap:
	\begin{center}
		\begin{tabular}{|l|c|}
			\hline
			Nucléotide/Gap & Représentation \\
			\hline
			\hline
			C & 0 \\
			\hline
			G & 1\\
			\hline
			T &  2 \\
			\hline
			A &  3 \\
			\hline
			Gap & 4 \\
			\hline

		\end{tabular}
	\end{center}

	Le fait de stocker les nucléotides sous forme de Bytes permet de réduire l'espace mémoire nécessaire pour retenir en mémoire une séquence d'ADN. En effet, si nous avions stocké naïvement les séquences sous forme d'un String chaque caractère de la chaîne prendrait 4 octets contre 1 octet les caractères à l'aide d'un byte.

\subsection{Alignement semi-global}
\label{subsection:semiGlobal}

Une des premières étapes de notre démarche est d'effectuer un alignement semi-global
de deux séquences. Le calcul d'une matrice de similarités entre les deux séquences à aligner doit être effectué. A partir de certaines valeurs associées à un gap ( ex: \begin{tabular}{c} A \\ - \end{tabular} ou \begin{tabular}{c} - \\ A \end{tabular} ), à un match (\begin{tabular}{c} A \\ A \end{tabular}) et à un missmatch (\begin{tabular}{c} A \\ C \end{tabular}) celle-ci permet de calculer les différents scores des alignements possibles entre les deux séquences. Dans le cadre d'un alignement semi-global, le score d'alignement correspond à la somme des scores 
Dans le cadre de ce projet, nous utilisons les valeurs suivantes:

\begin{center}
	\begin{tabular}{|l|c|}
		\hline
		 & Valeur \\
		\hline
		\hline
		match & 1 \\
		\hline
	 	missmatch & -1\\
		\hline
		gap &  -2 \\
		\hline
	\end{tabular}
\end{center}





 L'alignement semi-global est implémenté dans la classe \verb|Sequence| via la fonction \emph{semiGlobalAlignement} qui utilise la fonction \emph{computeSimMat} et \emph{backTrack}. Cette méthode prend deux séquences $f$ et $g$, les coûts de match, missmatch et gap et calcule l'alignement dont le score d'alignement est le plus élevé et  tel que $f$ précède $g$ - nous appelons cet alignement un alignement de type ($f,g$) - et celui tel que $g$ précède $f$ - nous appelons cet alignement un alignement de type ($g,f$)- et renvoie le résultat sous la forme d'une liste de \verb|SequenceAlignement|. Ce comportement est un différent de celui du cours, car dans ce dernier on se contentait de garder le meilleur des deux alignements du point de vue du score d'alignement. Ici nous sommes intéressés à la fois  au meilleur alignement suffixe-prefixe de $f$ avec $g$ mais également le cas inverse ($g$ avec $f$). Ces deux situations sont illustrés à la figure~\ref{fig:alignementType}.
On remarque que lorsque l'on calcule la matrice de similarité, si le fragment $f$ est placé sur l'axe vertical et si le fragment $g$ est placé sur l'axe horizontal, on trouve le score d'alignement de type $(f,g)$ en prenant le maximum sur la dernière ligne de la matrice. En effet, cela signifie que l'on a parcouru tous les éléments de la séquence $f$ avant de finir le parcours des éléments de la séquence $g$. De la même manière on trouve les alignements de type $(g,f)$ en prenant le maximum de la dernière colonne de la matrice.\\

\begin{figure}
	\begin{minipage}[r]{.46\linewidth}
		\begin{center}
		\includegraphics[scale= 0.50]{(f,g).png}
		Alignement de type (f,g)
	\end{center}
	   \end{minipage} \hfill
	   \begin{minipage}[c]{.46\linewidth}
		\begin{center}
			\includegraphics[scale= 0.50]{(g,f).png}
			Alignement de type (g,f)
		\end{center}
			  \end{minipage}
		\caption{Résultats de l'alignement de f et de g}
		\label{fig:alignementType}
\end{figure}


Un objet de la classe \verb|SequenceAlignement| est défini de la manière
suivante: le fragment $f$ aligné (stocké dans l'argument \emph{s1}) avec le segment $g$ (stocké dans l'argument \emph{s2}) en supposant que le
segment $f$ est le segment le plus à \og gauche \fg.

De plus,  dans la classe \verb|Sequence| nous retrouvons la méthode \emph{arcGenerator} qui à partir de deux fragments $f$ et $g$ calcule les alignements suivants:\\
\begin{itemize}
	\item[$\bullet$] Les alignements $(f,g)$ et $(g,f)$;
	\item[$\bullet$] Les alignements $(\overline{f},g)$ et $(g, \overline{f})$;
	\item[$\bullet$] Les alignements $(f, \overline{g})$ et $(\overline{g},f)$;
	\item[$\bullet$] Les alignements  $(\overline{f}, \overline{g})$ et $(\overline{g}, \overline{f})$.
\end{itemize}
Où $\overline{f}$ est le fragment complémentaire inversé de $f$.\\
Au vu des explications ci-dessus, il est important de remarquer que pour trouver les 8 alignements il n'est nécessaire de calculer uniquement 4 matrices de similarités (une pour chaque paire de l'énumération ci-dessus).\\

A partir de ces alignements, nous représentons les relations entre toutes les paires d'alignement sous la forme d'arcs. Un arc possède les attributs suivants:\\

\begin{itemize}
	\item[$\bullet$] Les fragments $f$ et $g$ initiaux qui sont utilisés lors de l'alignement. Ceux-ci sont stockés dans les attributs \emph{start} et \emph{end} qui représentent respectivement l'origine et de l'extrémité de l'arc.
	\item[$\bullet$] Des booléens relatifs à $f$ et $g$ - respectivement \emph{startComp} et \emph{endComp} qui permettent de savoir si on considère le complémentaire inversé lors de l'alignement.
	\item[$\bullet$] Le score correspondant à l'alignement.
	\item[$\bullet$] Un booléen \emph{inside} qui permet de déterminer si, lors de l'alignement, un des deux fragments est inclus à l'autre.
	
\end{itemize}

Nous pouvons remarquer que nous ne stockons pas, l'alignement résultant de l'alignement semi-global. En effet, comme à la fin du procédé le nombre d'alignements réels qui nous intéressent sont au nombre de $n-1$ (si $n$ est le nombre de fragments), il n'est pas nécessaire de stocker en mémoire tous les alignements possibles. Dans le but de gagner en mémoire, nous préférons dès lors recalculer l'alignement correspondant aux arcs choisis par l'algorithme greedy. Ceci est réalisé par le biais de la méthode \emph{getAlignement} de la classe \verb|Arc|.

Ces arcs nous permettent d'effectuer l'algorithme greedy pour trouver un chemin hamiltonien parcourant tous les fragments considérés.


\subsection{Algorithme greedy}
\label{subsection:greedy}

Avant de nous intéresser à l'algorithme greedy en tant que tel, nous allons expliquer une structure de données \emph{Union-Find} que nous utilisons pour l'implémentation de cet algorithme.

\subsubsection{Union-Find}

Une structure de donnée \og Union-Find \fg~est une structure permettant de représenter une relation d'équivalence . On peut effectuer trois opérations sur cette structure:
\begin{itemize}
\item[$\bullet$] L'opération \textsc{Find} permet de déterminer dans quelle classe d'équivalence se situe un élément.
\item[$\bullet$] L'opération \textsc{Union} permet de faire l'union entre deux classes d'équivalence.
\item[$\bullet$] L'opération \textsc{MakeSet} construit une classe d'équivalence qui ne contient qu'un seul élément
\end{itemize}

Dans l'implémentation que nous avons utilisée, chaque classe d'équivalence est représentée par un arbre pour lequel chaque noeud possède une référence vers son père. Dans un tel choix d'implémentation, la racine de chaque classe correspond au représentant de la classe d'équivalence.

L'idée est que l'opération \textsc{Find} permet de retourner à la racine de l'arbre et donc de déterminer quel est le représentant de la classe d'équivalence. Pour l'opération \textsc{Union}, on rattache la racine d'une des deux classes à celle de l'autre classe. Toutefois, une telle démarche pourrait amener à des arbres fortement déséquilibrés . Afin d'éviter cela, une heuristique sur la hauteur de l'arbre est utilisée. On retient le \emph{rang} de l'arbre et à chaque fois que l'on veut faire l'union de deux arbres on considère leur rang. On attache l'arbre de rang inférieur à la racine de l'arbre de rang supérieur. Les arbres qui ne contiennent qu'un seul élément sont de rang 0 et dès que l'on effectue l'union de deux arbres de même rang, le résultat de cette union a un rang d'une unité plus grand.

La complexité en temps pour les opérations sur cette structure de donnée ont une complexité amortie en $\mathcal{O}(\alpha (n))$ où $\alpha(n)$ est l'inverse de la fonction $n = f(x) = A(x,x)$ où $A$ est la fonction de Ackermann. Cette fonction est une fonction qui croit très vite. En pratique, $\alpha(n)$ vaut moins de 5 pour toute valeur de $n$. Dès lors la complexité amortie des opérations sur Union-Find est en temps constant.

Nous avons basé notre implémentation et nos explications sur la page : \url{https://fr.wikipedia.org/wiki/Union-Find}
\subsubsection{Recherche du chemin hamiltonien}

Afin de trouver la meilleure séquence finale, nous devons trouver un chemin hamiltonien de poids maximal dans le graphe composé des arcs dont la construction est décrite dans la section~\ref{subsection:semiGlobal}. Le déroulement général de l'algorithme greedy est le suivant: à chaque étape d'exécution de l'algorithme, l'algorithme sélectionne et retire l'arc de poids le plus élevés d'un ensemble d'arcs. Plusieurs critères doivent alors être vérifiés pour savoir si l'arc doit être retenu. Si l'arc est l'arc $(f,g)$ où $f$ est l'origine de l'arc et $g$ son extrémité, il faut vérifier qu'on ne soit pas déjà rentré dans le \og noeud \fg~$g$ ni qu'on ne soit déjà sorti du \og noeud \fg~$f$, de plus, il faut s'assurer que $f$ et $g$ ne fasse pas déjà partie de la même classe d'équivalence. Vu que dans notre cas, nous travaillons également avec les complémentaires inversés, il faut s'assurer que lorsqu'un fragment $f$ est choisi pour la formation du chemin hamiltonien, il ne sera plus possible d'utiliser son complémentaire inversé $\overline{f}$.

La mise en oeuvre de l'algorithme greedy se trouve dans la classe \verb|Greedy|. Nous détaillons ci-dessous le rôle des différentes méthodes qui s'y trouvent.

\begin{description}
	\item[\textsc{generateAllPairs}] Cette méthode permet à partir d'une liste d'objets \verb|Sequence| de générer toutes les paires de séquences qui devront être considérées.
	\item[\textsc{isAcceptable}] Pour un arc donné, cette méthode permet de déterminer si cet arc suit les conditions d'acceptabilité expliquées ci-dessus. 
	\item[\textsc{filterArcs}] C'est au sein de cette méthode que l'algorithme greedy comme décrit dans le cours est effectué. A partir d'une liste d'arcs, on calcule les sequences ayant générés ces arcs afin de pouvoir générer la structure d'\verb|Union-find|. Deux ensembles \emph{entered} et \emph{exited} permettent de tenir à jour les \og noeuds \fg~dans lesquels on est rentré ou sorti. Une autre structure \emph{comp} permet de savoir déterminer si on a déjà utilisé un fragment et si oui, s'il est utilisé sous sa forme complémentée inversée ou pas. L'algorithme choisit à chaque fois l'arc de poids le plus élevé et teste s'il est acceptable. Si oui, on ajoute cet arc pour la construction du chemin hamiltonien et on met à jour toutes les structures décrites précédemment et on choisit un nouvel arc. Si non, on choisit directement un nouvel arc.
	\item[\textsc{hamiltonianPath}] A partir de l'ensemble des arcs acceptés par la méthode \emph{filterArcs} reconstruit le chemin hamiltonien sous forme d'une liste d'arcs.
	\item[\textsc{greedy}] Cette méthode rassemble toutes les méthodes précédentes. On commence par générer toutes les paires de séquences possibles. A partir de cela, nous construisons les arcs. C'est à cet endroit que le travail est le plus couteux (car il demande de calculer les matrices de similarité). C'est pourquoi nous parallélisons cette étape. Nous avons ensuite la possibilité de retenir certains arcs selon certains critères. Nous avons tenté de rejeter les arcs qui correspondaient un alignement de type \og inside \fg. Les tests effectués après cette modification semblant donner des résultats moins bons, cette alternative n'a pas été retenue. Nous n'avons dès lors, à ce jour, pas encore trouvé de moyen efficace de traiter les alignements de type \og inside \fg. Nous construisons ensuite le chemin hamiltonien d'arcs. Toutefois, les alignements n'étant pas stocké dans les arcs, nous devons recalculer les alignements entre les deux séquences. Cela se fait via le biais de la fonction \emph{getAlignement} de la classe \verb|Arc|. 
	Ensuite, on renvoie le chemin hamiltonien de \verb|SequenceAlignment| qui est ainsi prêt à être utilisé pour retrouver la séquence finale.	
\end{description}

\input{alignementConsensus}
