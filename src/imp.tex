%!TEX root=rapport.tex
\section{Implémentation}

\subsection{Idée générale}

	L'idée générale de l'alignement de séquences est de permettre à partir d'un ensemble de séquences de créer à l'aide de chevauchements approximatif un \emph{contig}. Pour se faire, notre démarche se découpe en plusieurs parties:

	\begin{description}
		\item[Récupération et stockage des données] Afin de pouvoir former le contig souhaité, il est nécessaire de récupérer les séquences et de les stocker de manière efficace. Cette étape est expliquée dans la section~\ref{subsection:recStock}.

		\item[Alignement semi-global] Ensuite, pour chaque paire de séquence,
			nous effectuons un \emph{alignement semi-global} en nous inspirant
			de l'algorithme vu en cours. Cette méthode nous donne ainsi
			l'alignement approximatif des deux séquences, ce qui permet de
			prendre en compte le fait qu'il ait pu y avoir des erreurs lors du
			séquençage. Si la paire est noté $(s, t)$, cette étape nous permet également de connaitre la plus
			grande chaine qui est suffixe de $s$ et préfixe de $t$. Cette étape
			est expliquée dans la section~\ref{subsection:semiGlobal}.

		\item[Algorithme greedy] Une fois les alignements approximatifs
			calculés, il est encore nécessaire de trouver dans quel ordre
			ceux-ci doivent être assemblés afin de former le meilleur contig.
			Pour se faire, nous utilisons un \emph{algorithme greedy} qui, à
			partir d'un graphe permet de trouver un chemin hamiltonien afin de
			reconstituer le contig. Cette étape est expliquée dans la
			section~\ref{subsection:greedy}.

		\item[Alignement]
			L'algorithme greedy nous donnant, dans l'ordre, les séquences à
			aligner, il est nécessaire de reconstruire cet alignement en
			ajoutant des gaps pour que chaque séquence ait la même longueur et
			qu'on puisse calculer le consensus. Cette étape est expliquée dans
			la section ~\ref{subsection:alignment}.

		\item[Consensus]
			Maintenant que l'alignement a été réalisé, il nous faut calculer le
			consensus en fonction de ce dernier. Cette étape est expliquée dans
			la section ~\ref{subsection:consensus}.
	\end{description}

\subsection{Récupération et stockage des données}
\label{subsection:recStock}

Cette étape est effectuée au travers des classes \verb|FastaReader| et \verb|Alignement|. De plus, la classe \verb|FastaWriter| est utilisée afin de récupérer le résultat du procédé visant à trouver le meilleur contig.\\

La classe \verb|Alignment| permet de stocker sous forme d'un table de Bytes un fragment d'ADN. Nous prenons la convention suivante quant à la représentation des nucléotides et d'un gap:
	\begin{center}
		\begin{tabular}{|l|c|}
			\hline
			Nucléotide/Gap & Représentation \\
			\hline
			\hline
			C & int 0 \\
			\hline
			G & int 1\\
			\hline
			T & int 2 \\
			\hline
			A & int 3 \\
			\hline
			Gap & int 4 \\
			\hline

		\end{tabular}
	\end{center}

	Le fait de stocker les nucléotides sous forme de Bytes permet de réduire l'espace mémoire nécessaire.

	  Elle contient également des méthodes intéressantes telles que \textsc{complement} qui permet de complémenter une séquence d'ADN ainsi que d'autres méthodes comme \textsc{backTrack} et \textsc{semiGlobalAlignment} qui sont utiles pour l'étape décrire dans la section~\ref{subsection:semiGlobal} ou encore \textsc{arcGenerator} qui est expliquée dans la section~\ref{subsection:greedy}.\\

La classe \verb|FastaReader| permet à partir d'un \emph{fichier Fasta} de générer un liste d'objets \verb|Sequence| représentant les fragments d'ADN. \\

L'opération inverse est possible grâce à la classe \verb|FastaWriter|.





\subsection{Alignement semi-global}
\label{subsection:semiGlobal}

Une des premières étapes de la démarche est d'effectuer l'alignement semi-global
entre deux fragments. Cette étape permet de tester la similarité entre les deux
fragments que l'on veut aligner. L'alignement semi-global est implémenté dans la
classe \verb|Sequence| via la fonction \textsc{semiGlobalAlignement}. Cette
méthode prend deux fragments $s$ et $t$, des coûts de match, missmatch et gap
et calcule l'alignement de $s$ par rapport à $t$ et $t$ par rapport à $s$ et
renvoie le résultat sous forme d'une liste de \verb|SequenceAlignement|.\\

Un objet de la classe \verb|SequenceAlignement| est défini de la manière
suivante: le segment $s_1$ aligné avec le segment $s_2$ en supposant que le
segment $s_1$ est le segment le plus à \og gauche \fg. De plus, la longueur du
préfixe-suffixe commun est stocké dans l'attribut \emph{longestCommonSubstringLength}.\\

De plus, dans la classe \verb|Sequence| nous retrouvons la méthode \emph{arcGenerator} qui à partir de deux fragments $s_1$ et $s_2$ calcule tous les alignements possibles. C'est-à-dire, si on considère que $\overline{s_1}$ est le fragment complémentaire inversé de $s_1$, alors on calcule:\\
\begin{itemize}
	\item[$\bullet$] L'alignement $(s_1,s_2)$ ainsi que $(s_2,s_1)$;
	\item[$\bullet$] L'alignement de $(\overline{s_1},s_2)$ ainsi que $(s_2, \overline{s_1})$;
	\item[$\bullet$] L'alignement de $(s_1, \overline{s_2})$ ainsi que $(\overline{s_2},s_1)$;
	\item[$\bullet$] L'alignement de $(\overline{s_1}, \overline{s_2})$ ainsi que $(\overline{s_2}, \overline{s_1})$.
\end{itemize}
$ $\\
A partir de ces alignements nous construisons les objets \verb|Arc|. Un objet arc possède en attribut:\\

\begin{itemize}
	\item[$\bullet$] Les fragments $s_1$ et $s_2$ initiaux qui sont utilisés lors de l'alignement.
	\item[$\bullet$] Des booléens \emph{s1Comp} et \emph{s1Comp} qui permettent de savoir si on considère le complémentaire inversé lors de l'alignement.
	\item[$\bullet$] Les alignements \emph{s1Aligned} et \emph{s2Aligned}  résultant de l'exécution de l'algorithme d'alignement semi-global.
\end{itemize}

Ces arcs nous permettent d'effectuer l'algorithme greedy pour trouver un chemin hamiltonien parcourant tous les fragments considérés.


\subsection{Algorithme greedy}
\label{subsection:greedy}

Avant de nous intéresser à l'algorithme greedy en tant que tel, nous allons expliquer une structure de données \emph{Union-Find} que nous avons utilisée afin d'implémenter cet algorithme.

\subsubsection{Union-Find}

Une structure de donnée \og Union-Find \fg~est une structure permettant de représenter une relation d'équivalence . On peut effectuer trois opérations sur cette structure:
\begin{itemize}
\item[$\bullet$] L'opération \textsc{Find} permet de déterminer dans quelle classe d'équivalence se situe un élément.
\item[$\bullet$] L'opération \textsc{Union} permet de faire l'union entre deux classes d'équivalence.
\item[$\bullet$] L'opération \textsc{MakeSet} construit une classe d'équivalence qui ne contient qu'un seul élément
\end{itemize}

Dans l'implémentation que nous avons utilisée, chaque classe d'équivalence est représentée par un arbre pour lequel chaque noeud possède une référence vers son père. Dans un tel choix d'implémentation, la racine de chaque classe correspond au représentant de la classe d'équivalence.

L'idée est que l'opération \textsc{Find} permet de retourner à la racine de l'arbre et donc de déterminer quel est le représentant de la classe d'équivalence. Pour l'opération \textsc{Union}, on rattache la racine d'une des deux classes à celle de l'autre classe. Toutefois, une telle démarche pourrait amener à des arbres fortement déséquilibrés . Afin d'éviter cela, une heuristique sur la hauteur de l'arbre est utilisée. On retient le \emph{rang} de l'arbre et à chaque fois que l'on veut faire l'union de deux arbres on considère leur rang. On attache l'arbre de rang inférieur à la racine de l'arbre de rang supérieur. Les arbres qui ne contiennent qu'un seul élément sont de rang 0 et dès que l'on effectue l'union de deux arbres de même rang, le résultat de cette union a un rang d'une unité plus grand.

\subsection{Alignement}
\label{subsection:alignment}
Les deux dernières étapes que sont l'alignement et le consensus sont 
implémentées dans la classe \verb|ConsensusAbstract| à travers les méthodes 
\verb|computeAlignment| qui calcule l'alignement des séquences et le sauvegarde 
dans l'attribut \verb|alignment| ainsi qu'à travers la méthode \verb|build| 
qui calcule le consensus.

Pour calculer l'alignement, nous utilisons les segments alignés ans l'ordre 
donné par l'algorithme greedy décrit à l'étape \ref{subsection:greedy}.
L'algorithme greedy nous ressort une liste de paires de séquences $P_{i}$ tel
que le deuxième segment de la paire $P_{i}$ provient du même segment initial que
le premier de la paire $P_{i + 1}$, la différence se situant dans les gaps
ajoutés lors de l'alignement semi-global entre les nucléotides pour offrir le
meilleur score pour chaque paire.

Pour pouvoir construire le contig final, il nous faut réaligner convenablement
chaque paire de segments et pour cela, nous allons propager les gaps qui ont été
ajoutés lors des calculs de l'alignement semi-global. Nous effectuons cette
propagation en deux temps:

\begin{enumerate}
	\item vers le bas, c'est-à-dire, pour une paire $P_{i}$ on regarde si, entre
		deux nucléotides de la deuxième composante de $P_{i}$, le
		nombre de gaps est plus grand qu'entre les deux mêmes nucléotides de la première
		séquence de la paire suivante $P_{i + 1}$ et si c'est le cas, on propage la
		différence entre ces nombres vers les séquences du dessous.
	\item vers le haut par le même procédé que pour la propagation vers le bas
		sauf que nous propageons les gaps qui sont plus présents dans la
		première composante de la paire $P_{i + 1}$ que dans la deuxième
		composante de paire $P_{i}$ et qu'on propage alors la différence de gaps
		vers les séquences du dessus.
\end{enumerate}

Grace à ce procédé, nous sommes sûrs que les séquences résultantes des
alignements semi-globaux sont bien les mêmes et que l'ordre renvoyé par le greedy
est toujours le même (car l'ordre des scores reste le même).

\subsubsection{Représentation d'une séquence pour l'alignement}

Au vu de cette méthode de propagation de gaps, le procédé d'alignement n'est
donc qu'un ajout de gaps entre nucléotides: il est alors intéressant de
représenter les séquences alignées comme des séquences sans gaps où, après
chaque nucléotide de la séquence, nous retenons, dans un tableau d'entier, le
nombre de gaps suivant celui-ci.\footnote{Une même représentation peut être
	utilisée pour représenter pour les nucléotides successifs identiques: nous
	compressons ainsi la séquence. Nous n'avons souhaité compresser que les gaps
	car nous n'allons travailler qu'avec ceux-ci, et cela aurait complexifié
l'implémentation des méthodes.}

Par exemple, la séquence \verb|A--T-G-C| sera représenté par une séquence
\verb|ATGC| et par un tableau nommé \verb|nb_gaps| de taille 4
contenant les entiers {2, 1, 1, 0} car il y a deux gaps après le premier
nucléotide, un gap après le second, un après le troisième, et 0 à la fin. Les
complexités en temps et en mémoire sont ainsi diminuées.
Au niveau de la mémoire, une séquence alignée se voit ainsi 'compressée'.

L'ajout de gaps sera alors très simple et très rapide en complexité. En effet,
si nous souhaitons ajouter un gap à la position 2 (supposons qu'on commence en
0) à la séquence \verb|A--T-G-C| pour obtenir \verb|A---T-G-C|, il nous suffira
d'augmenter de 1 le nombre de gaps après le nucléotide A: nous obtiendrons alors
le tableau {3, 1, 1, 0}. Cet ajout de gap peut se faire en $O(n)$ où $n$ est la
taille de la séquence \textit{initiale}. De plus, l'insertion de gaps ne demande
pas plus d'espace mémoire: qu'importe si nous devons insérer $2$ gaps ou $10000$
gaps.\footnote{Avec la représentation sous forme de byte (1 octet en Java),
	cette nouvelle abstraction est intéressante si nous devons ajouter plus de 7
	gaps entre chaque nucléotide (un entier prenant 8 octets), ce qui peut
arriver si nous travaillons sur de grandes séquences.}

Un autre point positif est qu'il est très facile de connaitre la position où nous
devons insérer des gaps s'il nous est demandé de rajouter $n$ gaps entre deux
nucléotides: il suffit de connaitre la position du nucléotide dans la chaine
initiale après lequel nous devons ajouter les $n$ gaps.

Cette abstractation des séquences est réalisée dans la classe
\verb|SequenceAbstract|.\footnote{Cela justifie le nom de la classe
	\verb|ConsensusAbstract| qui travaille avec des objets de la classe
\verb|SequenceAbstract|, et non \verb|Squence|.}

\subsection{Consensus}
\label{subsection:consensus}

Grace à l'alignement précédemment réalisé, nos paires $P_{i}$ et $P_{i + 1}$ ont
maintenant la même séquence respectivement en deuxième composante et en première
composante et toutes les séquences sont maintenant bien alignées. Pour
construire le contig final, nous allons parcourir chaque colonne de l'alignement
et prendre le nucléotide qui apparait le plus souvent. En cas d'égalité, nous
prenons par ordre alphabétique.
